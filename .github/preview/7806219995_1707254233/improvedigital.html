
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>improvedigital: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/prebid/prebid-server/v2/adapters/improvedigital/improvedigital.go (90.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package improvedigital

import (
        "encoding/json"
        "fmt"
        "net/http"
        "regexp"
        "strconv"
        "strings"

        "github.com/prebid/openrtb/v20/openrtb2"
        "github.com/prebid/prebid-server/v2/adapters"
        "github.com/prebid/prebid-server/v2/config"
        "github.com/prebid/prebid-server/v2/errortypes"
        "github.com/prebid/prebid-server/v2/openrtb_ext"
)

const (
        isRewardedInventory              = "is_rewarded_inventory"
        stateRewardedInventoryEnable     = "1"
        consentProvidersSettingsInputKey = "ConsentedProvidersSettings"
        consentProvidersSettingsOutKey   = "consented_providers_settings"
        consentedProvidersKey            = "consented_providers"
        publisherEndpointParam           = "{PublisherId}"
)

type ImprovedigitalAdapter struct {
        endpoint string
}

// BidExt represents Improved Digital bid extension with line item ID and buying type values
type BidExt struct {
        Improvedigital struct {
                LineItemID int    `json:"line_item_id"`
                BuyingType string `json:"buying_type"`
        }
}

// ImpExtBidder represents Improved Digital bid extension with Publisher ID
type ImpExtBidder struct {
        Bidder struct {
                PublisherID int `json:"publisherId"`
        }
}

var dealDetectionRegEx = regexp.MustCompile("(classic|deal)")

// MakeRequests makes the HTTP requests which should be made to fetch bids.
func (a *ImprovedigitalAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) <span class="cov8" title="1">{
        numRequests := len(request.Imp)
        errors := make([]error, 0)
        adapterRequests := make([]*adapters.RequestData, 0, numRequests)

        // Split multi-imp request into multiple ad server requests. SRA is currently not recommended.
        for i := 0; i &lt; numRequests; i++ </span><span class="cov8" title="1">{
                if adapterReq, err := a.makeRequest(*request, request.Imp[i]); err == nil </span><span class="cov8" title="1">{
                        adapterRequests = append(adapterRequests, adapterReq)
                }</span> else<span class="cov0" title="0"> {
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov8" title="1">return adapterRequests, errors</span>
}

func (a *ImprovedigitalAdapter) makeRequest(request openrtb2.BidRequest, imp openrtb2.Imp) (*adapters.RequestData, error) <span class="cov8" title="1">{
        // Handle Rewarded Inventory
        impExt, err := getImpExtWithRewardedInventory(imp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if impExt != nil </span><span class="cov8" title="1">{
                imp.Ext = impExt
        }</span>

        <span class="cov8" title="1">request.Imp = []openrtb2.Imp{imp}

        userExtAddtlConsent, err := a.getAdditionalConsentProvidersUserExt(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(userExtAddtlConsent) &gt; 0 </span><span class="cov8" title="1">{
                userCopy := *request.User
                userCopy.Ext = userExtAddtlConsent
                request.User = &amp;userCopy
        }</span>

        <span class="cov8" title="1">reqJSON, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">headers := http.Header{}
        headers.Add("Content-Type", "application/json;charset=utf-8")

        return &amp;adapters.RequestData{
                Method:  "POST",
                Uri:     a.buildEndpointURL(imp),
                Body:    reqJSON,
                Headers: headers,
        }, nil</span>
}

// MakeBids unpacks the server's response into Bids.
func (a *ImprovedigitalAdapter) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) <span class="cov8" title="1">{
        if response.StatusCode == http.StatusNoContent </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if response.StatusCode == http.StatusBadRequest </span><span class="cov8" title="1">{
                return nil, []error{&amp;errortypes.BadInput{
                        Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
                }}
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, []error{&amp;errortypes.BadServerResponse{
                        Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
                }}
        }</span>

        <span class="cov8" title="1">var bidResp openrtb2.BidResponse
        var impMap = make(map[string]openrtb2.Imp)
        if err := json.Unmarshal(response.Body, &amp;bidResp); err != nil </span><span class="cov8" title="1">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">if len(bidResp.SeatBid) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if len(bidResp.SeatBid) &gt; 1 </span><span class="cov8" title="1">{
                return nil, []error{&amp;errortypes.BadServerResponse{
                        Message: fmt.Sprintf("Unexpected SeatBid! Must be only one but have: %d", len(bidResp.SeatBid)),
                }}
        }</span>

        <span class="cov8" title="1">seatBid := bidResp.SeatBid[0]
        if len(seatBid.Bid) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">bidResponse := adapters.NewBidderResponseWithBidsCapacity(len(seatBid.Bid))
        bidResponse.Currency = bidResp.Cur

        for i := range internalRequest.Imp </span><span class="cov8" title="1">{
                impMap[internalRequest.Imp[i].ID] = internalRequest.Imp[i]
        }</span>

        <span class="cov8" title="1">for i := range seatBid.Bid </span><span class="cov8" title="1">{
                bid := seatBid.Bid[i]

                bidType, err := getBidType(bid, impMap)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, []error{err}
                }</span>

                <span class="cov8" title="1">if bid.Ext != nil </span><span class="cov8" title="1">{
                        var bidExt BidExt
                        err = json.Unmarshal(bid.Ext, &amp;bidExt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, []error{err}
                        }</span>

                        <span class="cov8" title="1">bidExtImprovedigital := bidExt.Improvedigital
                        if bidExtImprovedigital.LineItemID != 0 &amp;&amp; dealDetectionRegEx.MatchString(bidExtImprovedigital.BuyingType) </span><span class="cov8" title="1">{
                                bid.DealID = strconv.Itoa(bidExtImprovedigital.LineItemID)
                        }</span>
                }

                <span class="cov8" title="1">bidResponse.Bids = append(bidResponse.Bids, &amp;adapters.TypedBid{
                        Bid:     &amp;bid,
                        BidType: bidType,
                })</span>
        }
        <span class="cov8" title="1">return bidResponse, nil</span>
}

// Builder builds a new instance of the Improvedigital adapter for the given bidder with the given config.
func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) <span class="cov8" title="1">{
        bidder := &amp;ImprovedigitalAdapter{
                endpoint: config.Endpoint,
        }
        return bidder, nil
}</span>

func getBidType(bid openrtb2.Bid, impMap map[string]openrtb2.Imp) (openrtb_ext.BidType, error) <span class="cov8" title="1">{
        // there must be a matching imp against bid.ImpID
        imp, found := impMap[bid.ImpID]
        if !found </span><span class="cov8" title="1">{
                return "", &amp;errortypes.BadServerResponse{
                        Message: fmt.Sprintf("Failed to find impression for ID: \"%s\"", bid.ImpID),
                }
        }</span>

        // if MType is not set in server response, try to determine it
        <span class="cov8" title="1">if bid.MType == 0 </span><span class="cov8" title="1">{
                if !isMultiFormatImp(imp) </span><span class="cov8" title="1">{
                        // Not a bid for multi format impression. So, determine MType from impression
                        if imp.Banner != nil </span><span class="cov8" title="1">{
                                bid.MType = openrtb2.MarkupBanner
                        }</span> else<span class="cov8" title="1"> if imp.Video != nil </span><span class="cov8" title="1">{
                                bid.MType = openrtb2.MarkupVideo
                        }</span> else<span class="cov8" title="1"> if imp.Audio != nil </span><span class="cov8" title="1">{
                                bid.MType = openrtb2.MarkupAudio
                        }</span> else<span class="cov8" title="1"> if imp.Native != nil </span><span class="cov8" title="1">{
                                bid.MType = openrtb2.MarkupNative
                        }</span> else<span class="cov8" title="1"> { // This should not happen.
                                // Let's handle it just in case by returning an error.
                                return "", &amp;errortypes.BadServerResponse{
                                        Message: fmt.Sprintf("Could not determine MType from impression with ID: \"%s\"", bid.ImpID),
                                }
                        }</span>
                } else<span class="cov8" title="1"> {
                        return "", &amp;errortypes.BadServerResponse{
                                Message: fmt.Sprintf("Bid must have non-zero MType for multi format impression with ID: \"%s\"", bid.ImpID),
                        }
                }</span>
        }

        // map MType to BidType
        <span class="cov8" title="1">switch bid.MType </span>{
        case openrtb2.MarkupBanner:<span class="cov8" title="1">
                return openrtb_ext.BidTypeBanner, nil</span>
        case openrtb2.MarkupVideo:<span class="cov8" title="1">
                return openrtb_ext.BidTypeVideo, nil</span>
        case openrtb2.MarkupAudio:<span class="cov8" title="1">
                return openrtb_ext.BidTypeAudio, nil</span>
        case openrtb2.MarkupNative:<span class="cov8" title="1">
                return openrtb_ext.BidTypeNative, nil</span>
        default:<span class="cov8" title="1">
                // This shouldn't happen. Let's handle it just in case by returning an error.
                return "", &amp;errortypes.BadServerResponse{
                        Message: fmt.Sprintf("Unsupported MType %d for impression with ID: \"%s\"", bid.MType, bid.ImpID),
                }</span>
        }
}

func isMultiFormatImp(imp openrtb2.Imp) bool <span class="cov8" title="1">{
        formatCount := 0
        if imp.Banner != nil </span><span class="cov8" title="1">{
                formatCount++
        }</span>
        <span class="cov8" title="1">if imp.Video != nil </span><span class="cov8" title="1">{
                formatCount++
        }</span>
        <span class="cov8" title="1">if imp.Audio != nil </span><span class="cov8" title="1">{
                formatCount++
        }</span>
        <span class="cov8" title="1">if imp.Native != nil </span><span class="cov8" title="1">{
                formatCount++
        }</span>
        <span class="cov8" title="1">return formatCount &gt; 1</span>
}

// This method responsible to clone request and convert additional consent providers string to array when additional consent provider found
func (a *ImprovedigitalAdapter) getAdditionalConsentProvidersUserExt(request openrtb2.BidRequest) ([]byte, error) <span class="cov8" title="1">{
        var cpStr string

        // If user/user.ext not defined, no need to parse additional consent
        if request.User == nil || request.User.Ext == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Start validating additional consent
        // Check key exist user.ext.ConsentedProvidersSettings
        <span class="cov8" title="1">var userExtMap = make(map[string]json.RawMessage)
        if err := json.Unmarshal(request.User.Ext, &amp;userExtMap); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cpsMapValue, cpsJSONFound := userExtMap[consentProvidersSettingsInputKey]
        if !cpsJSONFound </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Check key exist user.ext.ConsentedProvidersSettings.consented_providers
        <span class="cov8" title="1">var cpMap = make(map[string]interface{})
        if err := json.Unmarshal(cpsMapValue, &amp;cpMap); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cpMapValue, cpJSONFound := cpMap[consentedProvidersKey]
        if !cpJSONFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        // End validating additional consent

        // Check if string contain ~, then substring after ~ to end of string
        <span class="cov8" title="1">consentStr := cpMapValue.(string)
        var consentStrParts = strings.Split(consentStr, "~")
        if len(consentStrParts) &lt; 2 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">cpStr = consentStrParts[1]
        if len(strings.TrimSpace(cpStr)) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        //cpStr = consentStr[:len(consentStr)-1]

        // Prepare consent providers string
        <span class="cov8" title="1">cpStr = fmt.Sprintf("[%s]", strings.Replace(cpStr, ".", ",", -1))
        cpMap[consentedProvidersKey] = json.RawMessage(cpStr)

        cpJSON, err := json.Marshal(cpMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">userExtMap[consentProvidersSettingsOutKey] = cpJSON

        extJson, err := json.Marshal(userExtMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return extJson, nil</span>
}

func getImpExtWithRewardedInventory(imp openrtb2.Imp) ([]byte, error) <span class="cov8" title="1">{
        var ext = make(map[string]json.RawMessage)
        if err := json.Unmarshal(imp.Ext, &amp;ext); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">prebidJSONValue, prebidJSONFound := ext["prebid"]
        if !prebidJSONFound </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var prebidMap = make(map[string]json.RawMessage)
        if err := json.Unmarshal(prebidJSONValue, &amp;prebidMap); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if rewardedInventory, foundRewardedInventory := prebidMap[isRewardedInventory]; foundRewardedInventory &amp;&amp; string(rewardedInventory) == stateRewardedInventoryEnable </span><span class="cov8" title="1">{
                ext[isRewardedInventory] = json.RawMessage(`true`)
                impExt, err := json.Marshal(ext)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return impExt, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func (a *ImprovedigitalAdapter) buildEndpointURL(imp openrtb2.Imp) string <span class="cov8" title="1">{
        publisherEndpoint := ""
        var impBidder ImpExtBidder

        err := json.Unmarshal(imp.Ext, &amp;impBidder)
        if err == nil &amp;&amp; impBidder.Bidder.PublisherID != 0 </span><span class="cov8" title="1">{
                publisherEndpoint = strconv.Itoa(impBidder.Bidder.PublisherID) + "/"
        }</span>

        <span class="cov8" title="1">return strings.Replace(a.endpoint, publisherEndpointParam, publisherEndpoint, -1)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
