name: adapter semgrep checks
on:
  pull_request
    # paths: ["adapters/*/*.go"]
jobs:
  semgrep-check:
    runs-on: ubuntu-latest
    steps:
        -   name: Install semgrep
            run: |
                pip3 install semgrep==1.22.0
                semgrep --version
                
        -   name: Install jq
            run: |
                pip3 install jq==1.4.1
                jq --version
                
        -   name: Checkout repo
            uses: actions/checkout@v3
            with:
                fetch-depth: 0

        -   name: Determine commit
            id: determine_commit
            run: |
                # run semgrep tests on all files when a pull request is opened
                # github.sha corresponds to the merged commit, enabling to fetch all updated files
                commit=${{ github.sha }}
                if [ "${{ github.event.action }}" == "synchronize" ]; then
                    # run semgrep tests only on files updated by latest non-merge commit
                    commit=${{ github.event.pull_request.head.sha }}
                fi
                echo "commit=${commit}" >> $GITHUB_OUTPUT

        -   name: Compute file changes
            id: compute_file_changes
            uses: actions/github-script@v4
            with:
                github-token: ${{ secrets.GITHUB_TOKEN }}
                result-encoding: string
                script: |
                    const ref = "${{ steps.determine_commit.outputs.commit }}"
                    const { owner, repo } = context.repo
                    let stats = {}
                    let dirs = []
                    
                    const response = await github.repos.getCommit({owner,repo,ref})
                    if (response != null && response.status === 200) {
                        const files = response.data.files
                        for (let i = 0; i < files.length; i++) {
                            const { filename, patch } = files[i];
                            const fileNameList = filename.split("/")
                            
                            if (
                            filename.endsWith(".go") && !filename.endsWith("_test.go") &&
                            filename.startsWith("adapters/") && fileNameList.length > 2
                            ) {
                                const lines = patch.split("\n");
                                if (lines.length === 1) {
                                continue;
                                }
                        
                                let lineNumber
                                for (let i = 0; i < lines.length; i++) {
                                    /*
                                        check if line is diff hunk header
                                        for example: 
                                            @@ -47,23 +47,26 @@
                                            +   func foo () {
                                        here @@ -47,23 +47,26 @@ is diff hunk header and 47 is lineNumber
                                    */ 
                                    if (lines[i].match(/@@\s.*?@@/) != null) {
                                        lineNumber = lines[i].match(/(\d+)/)[0]
                                        continue
                                    }

                                    if (lines[i].startsWith("-")) {
                                        continue
                                    }

                                    if (lines[i].startsWith("+")) {
                                        if (stats[filename] === undefined) {
                                            stats[filename] = [];
                                            let dir = "./adapters/"+fileNameList[1]+"/*"
                                            if (!dirs.includes(dir)) {
                                                dirs.push(dir)
                                            }
                                        }
                                        stats[filename].push(lineNumber)
                                    }
                                    lineNumber++;
                                }
                            }
                        }
                    }
                    return JSON.stringify({hasChanges: Object.keys(stats).length != 0, stats: stats, dirs: dirs.join(" ")})

        -   name: Export file changes
            id: export_file_changes
            run: |
                dirs=$(echo '${{ steps.compute_file_changes.outputs.result }}' | jq .dirs)
                hasChanges=$(echo '${{ steps.compute_file_changes.outputs.result }}' | jq .hasChanges)
                echo "dirs=${dirs}" >> $GITHUB_OUTPUT
                echo "hasChanges=${hasChanges}" >> $GITHUB_OUTPUT
                    
        -   name: Run semgrep tests
            if: contains(steps.export_file_changes.outputs.hasChanges, 'true')
            run: |
                outputs=$(semgrep --gitlab-sast --config=./semgrep/rules/adapter/prefer_http_utils.yml ${steps.export_file_changes.outputs.dirs} | jq '[.vulnerabilities[] | {"file": .location.file, "start": .location.start_line, "end": .location.end_line, "message": .message}]')
                cleaned_outputs=$(echo "$outputs" | tr -d '\n')
                parsed_outputs=$(echo "$cleaned_outputs" | jq -c '.[]')
                echo "$parsed_outputs" | while IFS= read -r obj; do
                    file=$(echo "$obj" | jq .'file')
                    start_line=$(echo "$obj" | jq .start)
                    end_line=$(echo "$obj" | jq .end)
                    message=$(echo "$obj" | jq .message)
  
                    echo "${file}"
                    echo "${start_line}"
                    echo "${end_line}"
                    echo "${message}"
                done
