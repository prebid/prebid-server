name: adapter semgrep checks
on:
  pull_request
    # paths: ["adapters/*/*.go"]
permissions: write-all
jobs:
  semgrep-check:
    runs-on: ubuntu-latest
    steps:
        -   name: Install semgrep
            run: |
                pip3 install semgrep==1.22.0
                semgrep --version
                
        -   name: Install jq
            run: |
                pip3 install jq==1.4.1
                jq --version
                
        -   name: Checkout repo
            uses: actions/checkout@v3
            with:
                fetch-depth: 0
        
        -   name: Compute commit changes
            id: compute_commit_changes
            uses: actions/github-script@v4
            with:
                github-token: ${{ secrets.GITHUB_TOKEN }}
                result-encoding: string
                script: |
                    const { owner, repo } = context.repo
                    const pullRequestNumber = context.payload.pull_request.number
                    let commit

                    async function getLatestCommit() {
                        const { data } = await github.pulls.listCommits({owner, repo, pull_number: pullRequestNumber}) 
                        // api returns commits in ascending order so loop in reverse to get latest commit
                        // latest commit can be merged master commit, such commit have more than one parent commits
                        // semgrep shouldn't scan changes part of merged master commit
                        for (let i = data.length-1; i >= 0; i--) {
                            const { sha, parents } = data[i]
                            if (parents.length == 1) {
                                return sha
                            }
                        }
                    }

                    async function getStats(files) {
                        let stats = {}
                        for (let i = 0; i < files.length; i++) {
                            const { filename, patch } = files[i]
            
                            // only consider non test go files that are part of adapter code
                            const fileNameList = filename.split("/")
                            if (filename.endsWith(".go") && !filename.endsWith("_test.go") && filename.startsWith("adapters/") && fileNameList.length > 2) {
                                const lines = patch.split("\n")
                                if (lines.length === 1) {
                                    continue
                                }
            
                                let lineNumber
                                for (let i = 0; i < lines.length; i++) {
                                    /* check if line is diff hunk header
                                    example:
                                        @@ -1,3 +1,3 @@
                                        1    var a
                                        2
                                        3   - //test
                                        3   +var b
                                    '@@ -1,3 +1,3 @@' is diff hunk header 
                                    */
                                    if (lines[i].match(/@@\s.*?@@/) != null) {
                                        lineNumber = lines[i].match(/(\d+)/)[0]
                                        continue
                                    }
                    
                                    // '-' indicates line was deleted. So do not consider deleted line
                                    if (lines[i].startsWith("-")) { continue }
            
                                    // '+' indicates line was added or updated. Include line number in commit change details
                                    if (lines[i].startsWith("+")) {
                                        if (stats[filename] === undefined) {
                                            stats[filename] = []
                                        }
                                        stats[filename].push(lineNumber)
                                    }
                                    lineNumber++
                                }
                            }
                        }
                        return stats
                    }

                    async function isTestExecutedOnCommit(ref) {
                        const { check_runs } = await github.checks.listForRef({owner, repo, ref})
                        for (let i = 0; i <= check_runs.length; i++) {
                            if (check_runs[i].name == "semgrep-check") {
                                return true
                            }
                        }
                        return false
                    }

                    async function computeCommitChanges() {
                        const pullRequestEvent = "${{ github.event.action }}"
                        const pullRequestMergeCommit = "${{ github.sha }}"
        
                        const { data } = await github.repos.getCommit({ owner, repo, ref:pullRequestMergeCommit })
                        const pullRequestStats = await getStats(data.files)
                        let stats = {}

                        //  check if a new commit was pushed after the pull request was opened
                        if (pullRequestEvent == "synchronize") {
                            commit = await getLatestCommit()
                            const { data } = await github.repos.getCommit({ owner, repo, ref:commit })
                            
                            if (!isTestExecutedOnCommit(commit)) {
                                const latestCommitStats = await getStats(data.files)
                                const fileNames = Object.keys(latestCommitStats)
                                for (let i = 0; i < fileNames.length; i++) {
                                    const fileName = fileNames[i]
                                    const commitChanges = latestCommitStats[fileName]
                                    const pullRequestChanges = pullRequestStats[fileName]
                                    if (pullRequestChanges == undefined) {
                                        continue
                                    }
                                    const changes = []
                                    for (let i = 0; i < commitChanges.length; i++) {
                                        if (pullRequestChanges.includes(commitChanges[i])) {
                                            changes.push(commitChanges[i])
                                        }
                                    }
                                    if (changes.length != 0) {
                                        stats[fileName] = changes
                                    }
                                }
                            }    
                        } else {
                            stats = pullRequestStats
                            commit = pullRequestMergeCommit
                        }
                        
                        const files = Object.keys(stats).join(" ")
                        return JSON.stringify({ hasChanges: files.length != 0, stats, files, commit })
                    }

                    return await computeCommitChanges()

        -   name: Export commit changes
            id: export_commit_changes
            run: |
                files=$(echo '${{ steps.compute_commit_changes.outputs.result }}' | jq .files)
                hasChanges=$(echo '${{ steps.compute_commit_changes.outputs.result }}' | jq .hasChanges)
                echo "files=${files}" >> $GITHUB_OUTPUT
                echo "hasChanges=${hasChanges}" >> $GITHUB_OUTPUT
                    
        -   name: Run semgrep tests
            id: run_semgrep_tests
            if: contains(steps.export_commit_changes.outputs.hasChanges, 'true')
            run: |
                unqouted_string=$(echo ${{ steps.export_commit_changes.outputs.files }} | tr -d '"')
                # run semgrep and export result as string
                outputs=$(semgrep --gitlab-sast --config=./semgrep/rules/adapter/prefer_http_utils.yml $unqouted_string  | jq '[.vulnerabilities[] | {"file": .location.file, "start": .location.start_line, "end": .location.end_line, "message": (.message | gsub("\\n"; "\n"))}]' | jq -c | jq -R)
                echo "semgrep_result=${outputs}" >> "$GITHUB_OUTPUT"

        -   name: Add pull request comment
            if: contains(steps.export_commit_changes.outputs.hasChanges, 'true')
            uses: actions/github-script@v4
            with:
                github-token: ${{ secrets.GITHUB_TOKEN }}
                result-encoding: string
                script: |
                    const semgrepResult = JSON.parse(${{ steps.run_semgrep_tests.outputs.semgrep_result }})
                    const  { stats, commit } = ${{ steps.compute_commit_changes.outputs.result }}
                    const { owner, repo } = context.repo
                    const pullRequestNumber = context.payload.pull_request.number

                    for (let i=0; i < semgrepResult.length; i++) {
                        const { file, start, end, message } = semgrepResult[i]
                        // check if semgrep suggested change is part of commit changes
                        const fileStats =  stats[file]
                        if (fileStats != undefined && (fileStats.includes(start) || fileStats.includes(end))) {
                            // add review on commit
                           await github.pulls.createReviewComment({owner: owner, repo: repo, pull_number: pullRequestNumber, body: message, commit_id: commit, path: file, line: start})
                        }
                    }
            env:
                GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

