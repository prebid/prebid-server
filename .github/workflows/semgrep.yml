name: adapter semgrep checks
on:
  pull_request
    # paths: ["adapters/*/*.go"]
jobs:
  semgrep-check:
    runs-on: ubuntu-latest
    steps:
        -   name: Install semgrep
            run: |
                pip3 install semgrep==1.22.0
                semgrep --version
                
        -   name: Install jq
            run: |
                pip3 install jq==1.4.1
                jq --version
                
        -   name: Checkout repo
            uses: actions/checkout@v3
            with:
                fetch-depth: 0

        -   name: Determine commit
            id: determine_commit
            run: |
                # run semgrep tests on all files when a pull request is opened
                # github.sha corresponds to the merged commit, enabling to fetch all updated files
                commit=${{ github.sha }}
                if [ "${{ github.event.action }}" == "synchronize" ]; then
                    # run semgrep tests only on files updated by latest non-merge commit
                    commit=${{ github.event.pull_request.head.sha }}
                fi
                echo "commit=${commit}" >> $GITHUB_OUTPUT

        -   name: Compute file changes
            id: compute_file_changes
            uses: actions/github-script@v4
            with:
                github-token: ${{ secrets.GITHUB_TOKEN }}
                result-encoding: string
                script: |
                    const ref = "${{ steps.determine_commit.outputs.commit }}"
                    const { owner, repo } = context.repo
                    let stats = {}
                    
                    const response = await github.repos.getCommit({owner,repo,ref})
                    if (response != null && response.status === 200) {
                        const files = response.data.files
                        for (let i = 0; i < files.length; i++) {
                            const { filename, patch } = files[i];
                            const fileNameList = filename.split("/")
                            
                            if (filename.endsWith(".go") && !filename.endsWith("_test.go") && filename.startsWith("adapters/") && fileNameList.length > 2) {
                                const lines = patch.split("\n");
                                if (lines.length === 1) {
                                continue;
                                }
                        
                                let lineNumber
                                for (let i = 0; i < lines.length; i++) {
                                    /*
                                        check if line is diff hunk header
                                        for example: 
                                            @@ -47,23 +47,26 @@
                                            +   func foo () {
                                        here @@ -47,23 +47,26 @@ is diff hunk header and 47 is lineNumber
                                    */ 
                                    if (lines[i].match(/@@\s.*?@@/) != null) {
                                        lineNumber = lines[i].match(/(\d+)/)[0]
                                        continue
                                    }

                                    if (lines[i].startsWith("-")) {
                                        continue
                                    }

                                    if (lines[i].startsWith("+")) {
                                        if (stats[filename] === undefined) {
                                            stats[filename] = [];
                                        }
                                        stats[filename].push(lineNumber)
                                    }
                                    lineNumber++;
                                }
                            }
                        }
                    }
                    const files = Object.keys(stats).join(" ")
                    return JSON.stringify({hasChanges: files.length != 0, stats: stats, files: files})

        -   name: Export file changes
            id: export_file_changes
            run: |
                files=$(echo '${{ steps.compute_file_changes.outputs.result }}' | jq .files)
                hasChanges=$(echo '${{ steps.compute_file_changes.outputs.result }}' | jq .hasChanges)
                echo "files=${files}" >> $GITHUB_OUTPUT
                echo "hasChanges=${hasChanges}" >> $GITHUB_OUTPUT
                    
        -   name: Run semgrep tests
            id: run_semgrep_tests
            if: contains(steps.export_file_changes.outputs.hasChanges, 'true')
            run: |
                unqouted_string=$(echo ${{ steps.export_file_changes.outputs.files }} | tr -d '"')
                outputs=$(semgrep --gitlab-sast --config=./semgrep/rules/adapter/prefer_http_utils.yml $unqouted_string  | jq '[.vulnerabilities[] | {"file": .location.file, "start": .location.start_line, "end": .location.end_line, "message": (.message | gsub("\\n"; "\n"))}]' | jq -c | jq -R)
                echo "semgrep_result=${outputs}" >> "$GITHUB_OUTPUT"

        -   name: Add pull request comment
            if: contains(steps.export_file_changes.outputs.hasChanges, 'true')
            uses: actions/github-script@v4
            with:
                github-token: ${{ secrets.GITHUB_TOKEN }}
                result-encoding: string
                script: |
                    const commit_sha = "${{ steps.determine_commit.outputs.commit }}"
                    const semgrepResult = JSON.parse(${{ steps.run_semgrep_tests.outputs.semgrep_result }})
                    const filesUpdated = ${{ steps.compute_file_changes.outputs.result }}
                    const { owner, repo } = context.repo
                    for (let i=0; i < semgrepResult.length; i++) {
                        const response = await github.repos.createCommitComment({owner,repo,commit_sha,body:semgrepResult[i].message});
                        console.log(response)
                        console.log("====")
                    }
            env:
                GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

